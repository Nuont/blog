---
title: MySql
date: 2021-06-07 11:13:38
author: L
top: true
cover: true
summary: MySql
categories: 数据库
tags:
  - MySql
---

## 数据库服务端操作

| 命令                               | 说明              |
| ---------------------------------- | ----------------- |
| sudo apt-get install mysql-server  | 安装数据库服务端  |
| sudo apt-get instarll mysql-client | 安装数据库客户端  |
| sudo service mysql status          | 查看mysql服务状态 |
| sudo service mysql stop            | 停止mysqk服务     |
| sudo service mysql start           | 启动mysql服务     |
| sudo service mysql restart         | 重启mysql服务     |

## 数据类型

* **数值: **

  **整形:**

  int、tinyint、bigint  

  **浮点型:**

  float：单精度型 只保证6位有效数字

  double: 双精度型，只保证16位有效数字的准确性

  decimal: 定点数,其中dicimal(5,2)代表共5位数字，其中2位是小数，

* **日期/时间:**

  date  年-月-日

  datetime 年-月-日  时:分:秒   	保存是时间范围: '1000-01-01 00:00:00' 到'9999-12-31 23:59:59'

  timestamp 年-月-日 时:分:"秒   保存是时间范围: '1970-01-01 00:00:01' 到'2038-01-19 03:14:07'

* **字符串:** 

  char:适用于知道固定长度的字符串

  varchar: 适用于不知道固定长度的字符串

  尽量使用varchar

  超过255字节的只能有varchar或者text,能用varchar的地方不用text.

* **枚举类型:**

  gender enum('男', '女','妖')

## 约束

| 约束类型    | 约束说明                               |
| ----------- | -------------------------------------- |
| not null    | 非空约束(设置非空约束，该字段不能为空) |
| primary key | 主键约束(唯一性，非空性)               |
| unique key  | 唯一约束(唯一性，可以空，但只能有一个) |
| default     | 默认约束(该数据的默认值)               |
| foreign key | 外键约束(需要建立两表间的关系)         |

## 登录与退出数据库命令

| 命令                  | 作用         |
| --------------------- | ------------ |
| mysql -u用户名 -p密码 | 连接数据库   |
| exit/quit/ctrl + d    | 退出数据库   |
| select version();     | 查看版本休息 |
| select now();         | 查看时间     |

## 数据库基本操作命令

| 命令                                    | 作用                 | 示例                                  |
| --------------------------------------- | -------------------- | ------------------------------------- |
| show create database 数据库名           | 查看创建数据库的语句 | show create database python;          |
| show databases()                        | 查看所有数据库       | show databases();                     |
| select database()                       | 查看当前使用的数据库 | select database();                    |
| create database 数据库名 charset=utf-8; | 创建数据库           | create database python charset=utf-8; |
| use 数据库名;                           | 使用数据库           | use python;                           |
| drop database 数据库名;                 | 删除数据库           | drop database python;                 |

```python
# 创建数据库 数据库中数据的编码采用的是安装数据库时指定的默认编码 utf8
CREATE DATABASE day21_1;
# 创建数据库 并指定数据库中数据的编码
CREATE DATABASE day21_1 CHARACTER SET utf8;
```

## 数据库基本操作命令

| 命令                     | 作用                   |
| ------------------------ | ---------------------- |
| show tables;             | 查看当前数据库中所有表 |
| desc 表名;               | 查看表结构             |
| show create table 表名； | 查看表的创建语句       |

### 表结构相关语句

* 创建表

  ```mysql
  # 格式:
  create table 表名(
  	字段名 类型(长度) 约束,
      字段名 类型(长度) 约束
  )
  # 例如 创建分类表
  create table sort(
   sid INT, # 分类ID
   sname VARCHAR(100) # 分类名称
  )
  ```

* 查看数据库所有表

  ```mysql
  # 查看数据库中的所有表
  # 格式
  show tables;
  
  # 查看表结构
  # 格式: desc 表名;
  # 例如:
  desc sort;
  ```

* 删除表

  ```mysql
  # 格式：
  drop table 表名;
  # 例如:
  drop table sort;
  ```

* 修改表结构格式

  ```mysql
  alter table 表名 add 列名 类型(长度) 约束;
  # 作用: 修改表添加列
  # 例如:
  # 1. 为分类表添加一个新的字段为分类描述 varchar(20)
  alter table sort add sdesc varchar(20);
  
  alter table 表名 modify 列名 类型(长度) 约束;
  # 作用: 修改表修改列的类型长度及约束
  # 例如:
  # 2. 为分类表的分类名称字段进行修改, 类型varchar(50) 添加约束 not null
  alter table sort modify sname varchar(50) not null;
  
  alter table 表名 change 旧列名 新列名 类型(长度) 约束;
  # 作用: 修改表修改列名
  # 例如:
  # 3. 为分类表的分类名称字段进行更换, 更换为snamesname varchar(30)
  alter table sort change sname snamename varchar(30);
  
  alter table 表名 drop 列名;
  # 作用: 修改表删除列
  # 例如:
  # 4. 删除分类表中snamename这列
  alter table sort drop snamename;
  
  rename table 表名 to 新表名
  # 作用: 修改表名
  # 例如:
  # 5. 为分类表sort改名为category
  rename table sort to category
  
  alter table 表名 character set 字符集
  # 作用:修改表的字符集
  # 例如:
  # 6. 为分类表category的编码进行修改
  ```

## 数据表结构修改命令

| 命令                                           | 作用         |
| ---------------------------------------------- | ------------ |
| alter table 表名 add 列名 类型;                | 添加字段     |
| alter table 表名 change 原名  新名  类型及约束 | 重命名字段   |
| alter table 表名 modify 列名  类型及约束       | 修改字段类型 |
| alter table 表名 drop 列名；                   | 删除字段     |
| drop table 表名;                               | 删除表       |
| alter table <旧表名> rename to <新表名>        | 修改表的名字 |

## 表数据操作命令

**添加数据**

| 命令                                                     | 作用                                             |
| -------------------------------------------------------- | ------------------------------------------------ |
| insert into 表名  values(...);                           | 全列插入：值的顺序与表结构字段的顺序完全一一对应 |
| insert into 表名(列1,..)values(值1,...);                 | 部分列插入: 值的顺序与给出的列顺序对应           |
| insert into 表名 values(...),(...)                       | 一次性插入多行数据                               |
| insert into 表名(列1,...) values(值1,...),(值1,...),...; | 部分列多行插入                                   |

**修改查询数据**

| 命令                                          | 作用           |
| --------------------------------------------- | -------------- |
| select * from 表名;                           | 查询所有列数据 |
| select 列1,列2,... from 表名;                 | 查询指定列数据 |
| select distinct                               | 去重查询       |
| update 表名 set 列1=值，列2=值... where 条件; | 修改数据       |

**删除数据**

 物理删除

| 命令                        | 作用     |
| --------------------------- | -------- |
| delete from 表名 where 条件 | 删除数据 |

逻辑删除

| 命令                                           | 作用                                                     |
| ---------------------------------------------- | -------------------------------------------------------- |
| alter table 表名 add is_delete bit default 0； | 增加一个字段，用这个字端来表示这条信息是否已经不能再使用 |
| update 表名 set is_delete=1 where 条件         | 修改字段，当为1时表示这条信息不能使用                    |

## where之比较运算查询

* where语句的作用

  使用where子句对表中的数据筛选,结果为true的记录会出现在结果集中

  语法:

  select * from 表名 where 条件;

* 常见的比较运算符

  等于：=

  大于：>

  大于等于: >=

  小于: <

  小于等于: <=

  不等于: != 或 <>

## where之逻辑运算查询

* 逻辑运算符

  and 表示有多个条件时，多个条件必须同时成立(值为True)

  or 表示有多个条件时，满足任意一个条件时成立

  not 表示取反操作

  注意：使用"()"运算符优先级问

## where之模糊查询

* 模糊查询

  模糊查询关键字:

  like

  like后跟:

  % 表示任意多个任意字符

  _ 表示一个任意字符

## where之范围查询

* 范围查询

  in 表示在一个非连续的范围内

  between...and...表示在一个连续的范围内

  注意：

  **between A and B 在匹配数据的时候匹配的范围空间是[A, B]**

## where之空值查询

* 判断为空

  判断为空: is null

  ```mysql
  select * from students where height is null
  ```

  **注意: null 与''是不同的**

* 判断非空

  判断非空: is not null

  ```mysql
  select * from students where height is not null
  ```

  **注意: is not null 顺序不要错误**

## order排序查询

* 排序查询语法:

  ```mysql
  select * from 表名 order by 列1 asc|desc [,列2 asc|desc]
  ```

  语法说明:

  * 将行数据按照列1进行排序，如果某项行列1的值相同时，则按照列2排序，以此类推
  * asc从小到大排序，即升序
  * desc从大到小排序，即降序
  * 默认按照列值从小到大排序(即asc关键字)

## 聚合函数

* 聚合函数

  | 命令        | 作用             |
  | ----------- | ---------------- |
  | count(字段) | 计算总行数       |
  | max(字段)   | 求此字段的最大值 |
  | min(字段)   | 求此字段的最小值 |
  | sum(字段)   | 求此字段之和     |
  | avg(字段)   | 求此字段平均值   |

* 聚合函数的作用

  **聚合函数的作用：聚合函数会把当前所在表当做一个组进行统计**

  聚合函数有以下几个特点:

  * 每个组哈数接收一个参数(字段名或者表达式)
  * 统计结果默认忽略字段为NULL的记录
  * 不允许出现嵌套 比如sum(max(xx))
  * round()四舍五入 : round(avg(age), 2)

## group 分组查询

* 什么是分组

  所谓的分组就是讲一个"数据集"划分成若干个"小区域"，然后针对若干个"小区域"进行数据处理

  **group by分组**

  * 使用特点

    group by的含义: 将查询结果按照1个或多个字段进行分组，字段值相同为一组

    group by可用于单个字段分组，也可用于多个字段分组

  **group by + group_concat()**

  * group_concat(字段名)作用: 根据分组结果，使用group_concat()来放置每一个分组中某字段的集合
  * select group_concat(name),gender from students group by gender;

  **group by + 聚合函数**

  * 作用: 聚合函数在和group by结合使用时候，统计的对象是每一个分组

  **group by + having**

  * having作用好where类似，但having只能用于group by对分组后的每组数据过滤，而where是用来过滤表的数据
  * select group_concat(name),gender from students group by gender having avg(age) > 30;

  **group by + with rollup 汇总的作用:**

  * **with rollup**的作用是: 在数据表最后新增一行，来记录当前表中该字段对应的操作结果，一般是汇总结果

  * select count(*), gender from students group by gender with rollup;

## limit限制查询

* limit限制查询

  可以使用limit限制取出记录的数量，但limit要写在sql语句的最后

  语法：

  ​	limit 起始记录，记录数

  说明: 

  * 起始记录是指从第几条记录开始取，第一天记录的下标为0
  * 记录数是指从起始记录开始向后依次取的记录数

## 连接查询

* 连接查询

  mysql支持三种类型的连接查询，分别为：

  * 内连接查询

    查询结果为两个表符合条件匹配到的数据

    语法：

    select 字段from 表1 inner join 表2 on 表1.字段1=表2.字段2

    注意: 

    1. 内连接： 根据链接条件取出两个表"交集"

       2. on 是连接条件 where是连接后筛选条件

* 外连接查询

  * 左连接

    左(外)连接查询：查询的结果为两个表匹配到的数据和左表特有的数据

    注意：对于右表中不存在的数据使用null填充

    **使用left join实际上左边表的所有数据都会显示出来**

  * 右连接

    右(外)连接查询：查询的结果为两个表匹配到的数据和右表特有的数据

    注意：对于左表中不存在的数据使用null填充

  语法：

  ​	左连接：主表 left join 从表 on 连接条件;

  ​	右连接:   从表 right join 主表 on 连接条件;

  注意：

  ​	能够使用连接的前提是，多表之间有字段上的关联

  ​	左连接和右连接区别在于主表在SQL语句中的位置，因此实际左连接就可以满足常见需求

* 自连接查询

  从sql文件中导入文件

  ```mysql
  source areas.sql
  ```

  ```
  使用自连接查询只需要使用一个表，可以加快查询速度，减少数据表占用空间
  
    **自连接查询本质还是连接查询**
  ```

## 子查询

子查询：把一个查询的结果当做另一查询的条件

子查询分为三类：

* 标量子查询：子查询返回的结果是一个数据(一行一列)
* 列子查询：返回的结果是一列(一列多行)
* 行子查询: 返回的结果是一行(一行多列)

## 外键

| 命令                                                         | 说明         |
| ------------------------------------------------------------ | ------------ |
| alter table 表名 add foreign key (列名) references 表名(列名) | 给表增加外键 |
| show create table 表名                                       | 获取外键名称 |
| alter table 表名 drop foreign key 外键约束名称               | 删除外键     |

## 视图

| 命令                               | 说明     |
| ---------------------------------- | -------- |
| create view 视图名称 as select语句 | 定义视图 |
| show tables;                       | 查看视图 |
| select * from v_goods_info;        | 使用视图 |
| drop view 视图名称                 | 删除视图 |

### 视图意义

1. 视图可以节省SQL语句: 将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作
2. 数据安全: 视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).
3. 视图往往是在大项目中使用, 而且是多系统使用: 可以对外提供有用的数据, 但是隐藏关键(无用)的数据: 数据安全
4. 视图可以对外提供友好型: 不同的视图提供不同的数据, 对外好像专门设计
5. 视图可以更好(容易)的进行权限控制

### 视图数据操作

视图是的确可以进行数据写操作的: 但是有很多限制

将数据直接在视图上进行操作.

* 新增数据

  数据新增就是直接对视图进行数据新增.

  1. 多表视图不能新增数据
  2. 可以向单表视图插入数据: 但是视图中包含的字段必须有基表中所有不能为空(或者没有默认值)字段
  3. 视图是可以向基表插入数据的.

* 删除数据

  多表视图不能删除数据

  单表视图可以删除数据

* 更新数据

  理论上不能单表视图还是多表示视图都可以更新数据.

  更新限制: with check option, 如果对视图在新增的时候,限定了某个字段有限制: 那么在对视图进行数据更新操作时,系统会进行验证: 要保证更新之后,数据依然可以被实体查询出来,否则不让更新.

## 事务

* 事务四大特性ACID
  1. 原子性：一个事物必须被视为一个不可分割的最小工作单元，整个事物中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性
  2. 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态
  3. 隔离性：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的
  4. 持久性：一旦事务提交，则其所做的修改会永久保存到数据库中

- 事务操作分为两种: 自动事务(默认的), 手动事务

  **手动事务操作流程:**

1. 开启事务: 告诉系统以下所有的操作(写)不要直接写入到数据表, 先存放到事务日志

start transaction;

2. 进行事务操作：一系列操作

3. 关闭事务: 选择性的将日志文件中操作的结果保存到数据表(同步)或者说直接清空事务日志(原来操作全部清空)

   a） 提交事务, 同步数据表(操作成功):commit;

   b)    回滚事务，直接清空日志表(操作失败):rollback;

- 自动事务处理

在mysql中: 默认的都是自动事务处理, 用户操作完会立即同步到数据表中.

自动事务: 系统通过autocommit变量控制

show variables like 'autocommit';

关闭自动提交： set autocommit = off/0

自动关闭之后,需要手动来选择处理: commit提交, rollback回滚

注意: 通常都会使用自动事务

- 事务原理

事务操作原理: 事务开启之后, 所有的操作都会临时保存到事务日志, 事务日志只有在得到commit命令才会同步到数据表,其他任何情况都会清空(rollback, 断电, 断开连接)

- 回滚点

回滚点: 在某个成功的操作完成之后, 后续的操作有可能成功有可能失败, 但是不管成功还是失败,前面操作都已经成功: 可以在当前成功的位置, 设置一个点: 可以供后续失败操作返回到该位置, 而不是返回所有操作, 这个点称之为回滚点.

设置回滚点语法: savepoint 回滚点名字;

回到回滚点语法: rollback to 回滚点名字;索引

| 命令                                                 | 说明             |
| ---------------------------------------------------- | ---------------- |
| show index from 表名                                 | 查看表中已有索引 |
| alter table 表名 add index 索引名[可选]\(字段名,...) | 创建索引         |
| drop index 索引名称 on 表名                          | 删除索引         |

**开启时间检测:**

set profiling=1;

**查看执行时间:**

show profiles;

使用原则:

1. 经常发生数据更新的表避免使用过多的索引
2. 数据量小的表没有必要使用索引
3. 数据量较大同时不会频发数据更新的表可以使用索引

## Python操作数据库

**pymysql使用步骤:**

1. 导入**pymysql**包

   import pymysql

2. 创建**连接对象**

   调用pymysql模块中的connect()函数来创建连接对象，代码如下：

   conn = connect(参数列表)

   * 参数host:连接的mysql主机, 如果本机是'localhost'
   * 参数port:连接的mysql主机的端口, 默认是3306
   * 参数user: 连接的用户名
   * 参数password: 连接的密码
   * 参数database: 数据库的名称
   * 参数charset:通信采用的编码方式。推荐使用utf8

   连接对象conn的相关操作

   * 关闭连接 conn.close()
   * 提交数据 conn.commit()
   * 撤销数据 conn.rollbock()

3. 获取**游标对象**

   获取游标对象的目标就是要执行sql语句，完成对数据库的增删改查。代码如下：

   调用连接对象的cursor()方法

   获取游标对象 cur = conn.cursor()

   游标操作说明:

   * 使用游标执行SQL语句：execute(opeartion [parameters]) 执行SQL语句，返回受影响的行数，主要用于执行insert ,update, delete, select等语句
   * 获取查询结果集中的一条数据: cur.fetchone()返回一个元组。如(1, '张三')
   * 获取查询结果集中的所有数据: cur.fetchall()返回一个元组。如((1, '张三'),(2, '李四'))
   * 关闭游标: cur.close()表示和数据库操作完成

4. pymysql完成数据的**增删改查**操作

   增删改查的sql语句

   sql = selct * from 数据表

   执行sql语句完成相关数据操作

   游标cursor.execute(sql)

5. 关闭**游标**和**连接**

   先关闭游标

   cur.close()

   后关闭连接
   conn.close()

* 防止SQL注入

  构造参数列表

  	params = [find_name]

  执行select 语句

  	sql = "select * from goods where name=%s" (这里的%s不需要加引号)
  	
  	cs.execute(sql, params)

## 范式

范式: Normal Format, 是一种离散数学中的知识, 是为了解决一种数据的存储与优化的问题: 保存数据的存储之后, 凡是能够通过关系寻找出来的数据,坚决不再重复存储: 终极目标是为了减少数据的冗余.

范式: 是一种分层结构的规范, 分为六层: 每一次层都比上一层更加严格: 若要满足下一层范式,前提是满足上一层范式.

六层范式: 1NF,2NF,3NF...6NF, 1NF是最底层,要求最低;6NF最高层,最严格.

但是数据库不单是要解决空间问题,要保证效率问题: 范式只为解决空间问题, 所以数据库的设计又不可能完全按照范式的要求实现: 一般情况下,只有前三种范式需要满足.

范式在数据库的设计当中是有指导意义: 但是不是强制规范.

### 1NF

第一范式: 在设计表存储数据的时候, 如果表中设计的字段存储的数据,在取出来使用之前还需要额外的处理(拆分),那么说表的设计不满足第一范式: **第一范式要求字段的数据具有原子性: 不可再分.**

讲师代课表

| **讲师** | **性别** | **班级** | **教室** | **代课时间** | **代课时间（开始，结束）** |
| -------- | -------- | -------- | -------- | ------------ | -------------------------- |
| 朱元璋   | Male     | php0226  | D302     | 30天         | 2014-02-27,2014-05-05      |
| 朱元璋   | Male     | php0320  | B206     | 30天         | 2014-03-21,2014-05-30      |
| 李世民   | Male     | php0320  | B206     | 15天         | 2014-06-01,2014-06-20      |

上表设计不存在问题: 但是如果需求是将数据查出来之后,要求显示一个老师从什么时候开始上课,到什么时候节课: 需要将代课时间进行拆分: 不符合1NF, 数据不具有原子性, 可以再拆分.

解决方案: 将代课时间拆分成两个字段就解决问题.

| **讲师** | **性别** | **班级** | **教室** | **代课时间** | **代课开始时间** | 代课结束时间 |
| -------- | -------- | -------- | -------- | ------------ | ---------------- | ------------ |
| 朱元璋   | Male     | php0226  | D302     | 30天         | 2014-02-27       | 2014-05-05   |
| 朱元璋   | Male     | php0320  | B206     | 30天         | 2014-03-21       | 2014-05-30   |
| 李世民   | Male     | php0320  | B206     | 15天         | 2014-06-01       | 2014-06-20   |

### 2NF

第二范式: 在数据表设计的过程中,**如果有复合主键(多字段主键), 且表中有字段并不是由整个主键来确定, 而是依赖主键中的某个字段(主键的部分): 存在字段依赖主键的部分的问题, 称之为部分依赖:** 第二范式就是要解决表设计不允许出现部分依赖.

| 讲师   | **性别** | **班级** | **教室** | **代课时间** | **代课开始时间** | 代课结束时间 |
| ------ | -------- | -------- | -------- | ------------ | ---------------- | ------------ |
| 朱元璋 | Male     | php0226  | D302     | 30天         | 2014-02-27       | 2014-05-05   |
| 朱元璋 | Male     | php0320  | B206     | 30天         | 2014-03-21       | 2014-05-30   |
| 李世民 | Male     | php0320  | B206     | 15天         | 2014-06-01       | 2014-06-20   |

以上表中: 因为讲师没有办法作为独立主键, 需要结合班级才能作为主键(复合主键: 一个老师在一个班永远只带一个阶段的课): 代课时间,开始和结束字段都与当前的代课主键(讲师和班级): 但是性别并不依赖班级, 教室不依赖讲师: 性别只依赖讲师, 教室只依赖班级: 出现了性别和教室依赖主键中的一部分: 部分依赖.不符合第二范式.

解决方案1: 可以将性别与讲师单独成表, 班级与教室也单独成表.

解决方案2: 取消复合主键, 使用逻辑主键

| IDP  | 讲师   | **性别** | **班级** | **教室** | **代课时间** | **代课开始时间** | 代课结束时间 |
| ---- | ------ | -------- | -------- | -------- | ------------ | ---------------- | ------------ |
| 1    | 朱元璋 | Male     | php0226  | D302     | 30天         | 2014-02-27       | 2014-05-05   |
| 2    | 朱元璋 | Male     | php0320  | B206     | 30天         | 2014-03-21       | 2014-05-30   |
| 3    | 李世民 | Male     | php0320  | B206     | 15天         | 2014-06-01       | 2014-06-20   |

ID = 讲师 + 班级(业务逻辑约束: 复合唯一键)

### 3NF

要满足第三范式,必须满足第二范式.

第三范式: 理论上讲,**应该一张表中的所有字段都应该直接依赖主键(逻辑主键: 代表的是业务主键), **如果表设计中存在一个字段, 并不直接依赖主键,而是通过某个非主键字段依赖,最终实现依赖主键: 把这种不是直接依赖主键,而是依赖非主键字段的依赖关系称之为传递依赖. 第三范式就是要解决传递依赖的问题.

| IDP  | 讲师   | **性别** | **班级** | **教室** | **代课时间** | **代课开始时间** | 代课结束时间 |
| ---- | ------ | -------- | -------- | -------- | ------------ | ---------------- | ------------ |
| 1    | 朱元璋 | Male     | php0226  | D302     | 30天         | 2014-02-27       | 2014-05-05   |
| 2    | 朱元璋 | Male     | php0320  | B206     | 30天         | 2014-03-21       | 2014-05-30   |
| 3    | 李世民 | Male     | php0320  | B206     | 15天         | 2014-06-01       | 2014-06-20   |

以上设计方案中: 性别依赖讲师存在, 讲师依赖主键; 教室依赖班级,班级依赖主键: 性别和教室都存在传递依赖.

解决方案: 将存在传递依赖的字段,以及依赖的字段本身单独取出,形成一个单独的表, 然后在需要对应的信息的时候, 使用对应的实体表的主键加进来.

讲师代课表:

| IDP  | 讲师ID | 班级ID | 代课时间 | 开始       | 结束       |
| ---- | ------ | ------ | -------- | ---------- | ---------- |
| 1    | 1      | 10     | 30       | 2014-02-27 | 2014-05-05 |
| 2    | 1      | 12     | 30       | 2014-03-21 | 2014-05-30 |
| 3    | 2      | 12     | 15       | 2014-06-01 | 2014-06-20 |

讲师表

| ID   | 讲师   | 性别 |
| ---- | ------ | ---- |
| 1    | 朱元璋 | Male |
| 2    | 李世民 | Male |

班级表:

| ID   | 班级    | 教室 |
| ---- | ------- | ---- |
| 10   | php0226 | 302  |
| 12   | php0320 | 206  |

### 逆规范化

有时候, 在设计表的时候,如果一张表中有几个字段是需要从另外的表中去获取信息. 理论上讲, 的确可以获取到想要的数据, 但是就是效率低一点. 会刻意的在某些表中,不去保存另外表的主键(逻辑主键), 而是**直接保存想要的数据信息:** 这样一来,在查询数据的时候, 一张表可以直接提供数据, 而不需要多表查询(效率低), 但是会导致数据冗余增加.
逆规范化: 磁盘利用率与效率的对抗

### 连接查询分类

SQL中将连接查询分成四类: 内连接,外连接,自然连接和交叉连接

### 交叉连接

交叉连接: cross join, 从一张表中循环取出每一条记录, 每条记录都去另外一张表进行匹配: 匹配一定保留(没有条件匹配), 而连接本身字段就会增加(保留),最终形成的结果叫做: 笛卡尔积.

基本语法：

左表 cross join 右表;

笛卡尔积没有意义: 应该尽量避免(交叉连接没用)

交叉连接存在的价值: 保证连接这种结构的完整性

### 内连接

内连接: [inner] join, 从左表中取出每一条记录,去右表中与所有的记录进行匹配: 匹配必须是某个条件在左表中与右表中相同最终才会保留结果,否则不保留.

基本语法：

左表 [inner] join 右表 on 左表.字段 = 右表.字段; on表示连接条件: 条件字段就是代表相同的业务含义(如my_student.c_id和my_class.id)

字段别名以及表别名的使用: 在查询数据的时候,不同表有同名字段,这个时候需要加上表名才能区分, 而表名太长, 通常可以使用别名.

内连接可以没有连接条件: 没有on之后的内容,这个时候系统会保留所有结果(笛卡尔积)

内连接还可以使用where代替on关键字(where没有on效率高)

### 外连接

外连接: outer join, 以某张表为主,取出里面的所有记录, 然后每条与另外一张表进行连接: 不管能不能匹配上条件,最终都会保留: 能比配,正确保留; 不能匹配,其他表的字段都置空NULL.

外连接分为两种: 是以某张表为主: 有主表

Left join: 左外连接(左连接), 以左表为主表

Right join: 右外连接(右连接), 以右表为主表
基本语法: 

左表 left/right join 右表 on 左表.字段 = 右表.字段;

虽然左连接和右连接有主表差异, 但是显示的结果: 左表的数据在左边,右表数据在右边.

### 子连接

子查询: sub query, 查询是在某个查询结果之上进行的.(一条select语句内部包含了另外一条select语句).

* 子查询分类

  子查询有两种分类方式: **按位置分类**和**按结果分类**

  按位置分类: 子查询(select语句)在外部查询(select语句)中出现的位置

  from子查询: 子查询跟在from之后

  where子查询: 子查询出现where条件中

  exists子查询: 子查询出现在exists里面

  

  按结果分类: 根据子查询得到的数据进行分类(理论上讲任何一个查询得到的结果都可以理解为二维表)

  标量子查询: 子查询得到的结果是一行一列

  列子查询: 子查询得到的结果是一列多行

  行子查询: 子查询得到的结果是多列一行(多行多列)

  上面几个出现的位置都是在where之后

  表子查询: 子查询得到的结果是多行多列(出现的位置是在from之后)

* 标量子查询

  需求: 知道班级名字为PHP0710,想获取该班的所有学生.

  ```mysql
  select * from my_student where c_id = (select id from my_class where c_name = 'PHP0710')
  ```

* 列子查询

  需求: 查询所有在读班级的学生(班级表中存在的班级)

  ```MYSQL
  select * from my_student where c_id in (select id from my_cless)
  ```

* 行子查询

  行子查询: 返回的结果可以是多行多列(一行多列)

  需求: 要求查询整个学生中,年龄最大且身高是最高的学生.

  ```mysql
  select * from my_student where (age, height) = (select max(age), max(height) from my_student)
  ```

* 表子查询

  表子查询: 子查询返回的结果是多行多列的二维表: 子查询返回的结果是当做二维表来使用

  找出每一个班最高的一个学生.

  ```mysql
  select * from (select * from my_student order by height desc)as student group by c_id;
  ```

* Exists查询

  exists: 是否存在的意思, exists子查询就是用来判断某些条件是否满足(跨表), exists是接在where之后: exists返回的结果只有0和1

  需求: 查询所有的学生: 前提条件是班级存在

  ```mysql
  select * from my_student where exists(select * from my_class where id = 1)
  ```

## 触发器

触发器: trigger, 事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行.

触发器: 事件类型, 触发时间, 触发对象

事件类型: 增删改, 三种类型insert,delete和update

触发时间: 前后: before和after

触发对象: 表中的每一条记录(行)

一张表中只能拥有一种触发时间的一种类型的触发器: 最多一张表能有6个触发器

### 创建触发器

在mysql高级结构中: 没有大括号,  都是用对应的字符符号代替

触发器基本语法:

-- 临时修改语句结束符

delimiter 自定义符号：后续代码中只有碰到自定义符号才算结束

create trigger 触发器名字 触发时间 时间类型  on 表名 for each row

begin -- 代表左大括号：开始

-- 里面是触发器的内容，每行内容都必须使用语句结束符：分号

end  -- 代表右大括号: 结束

-- 语句结束符

自定义符号

-- 将临时修改 修正过来

delimiter ;

```mysql
-- 触发器: 订单生成一个，商品库存就减少

-- 临时修改语句结束符
delimiter $$

create trigger after_order after insert on my_order for each row
begin
	-- 触发器内容
	update my_goods set inv = inv-1 where id =2;
end 
-- 结束触发器
$$

-- 修改修正结束符
delimiter ;
```

### 查看触发器

查看所有触发器或者模糊匹配

Show triggers [like ‘pattern’];

\g 的作用是分号和在sql语句中写’;’是等效的

\G 的作用是将查到的结构旋转90度变成纵向

可以查看触发器创建语句

Show create trigger 触发器名字;

所有的触发器都会保存一张表中: Information_schema.triggers

### 使用触发器

触发器: 不需要手动调用, 而是当某种情况发生时会自动触发.(订单里面插入记录之后)

### 修改触发器&删除触发器

触发器不能修改,只能先删除,后新增.

Drop trigger 触发器名字;

### 触发器记录

触发器记录: 不管触发器是否触发了,只要当某种操作准备执行, 系统就会将当前要操作的记录的当前状态和即将执行之后新的状态给分别保留下来, 供触发器使用: 其中, 要操作的当前状态保存到old中, 操作之后的可能形态保存给new.

Old和new都是代表记录本身: 任何一条记录除了有数据, 还有字段名字.

使用方式: old.字段名 / new.字段名(new代表的是假设发生之后的结果)

如果触发器内部只有一条要执行的SQL指令, 可以省略大括号(begin和end)

## 数据库

* 常见的数据库管理系统

  MYSQL ：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。

  Oracle ：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。

  DB2 ：IBM公司的数据库产品,收费的。常应用在银行系统中.

  SQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。

  SyBase ：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。

  SQLite : 嵌入式的小型数据库，应用在手机端。


### 数据库引擎

数据库引擎是用于存储、处理和保护数据的核心服务。
当你访问数据库时，不管是手工访问，还是程序访问，都不是直接读写数据库文件，而是通过数据库引擎去访问数据库文件
注意：数据引擎是指表格中的引擎，

### 数据库表

数据库中以表为组织单位存储数据

表类似与Python类, 每个字段都有对应的数据类型

用熟悉的Python程序来与关系型数据库对比，就会发现对应关系：

类 -----  表

类中的属性 ----  表中字段

对象 ----- 记录

### 表数据

根据表字段所规定的数据类型，我们可以向其中填入一条条的数据，而表中的每条数据类似类的实例对象。表中的一行一行的信息我们称之为记录。

##  SQL语句

### SQL语句

* SQL分类：

  1. 数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等

  2. 数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等

  3. 数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户。

  4. 数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等
